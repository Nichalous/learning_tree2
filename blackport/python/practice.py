
###################################################################

##Less than simple assignment 2
##make sure no one can get to a nonexisiting extension route of blackport

from bottle import Bottle, route, run, static_file, abort, error, response, request, hook
import subprocess, string, os

# change to True when running on loopy, False when running on scott
if True:
   server_ip     = '10.255.0.67'
   document_root = '/home/nick/projects/learning_tree2/blackport/html'
else:
   document_root = '/tmp/learning_tree2/blackport'
   server_ip     = '10.255.0.70'

##add error403.html
@error(403)
def ediquite(response):
    try:
        with open(os.path.join(document_root, 'error403.html')) as f:
            data = f.read()
    except Exception as e:
        data = 'omg?'

    return data


##add error404.html
@error(404)
def adiquite(response):
    try:
        with open(os.path.join(document_root, 'error404.html')) as f:
            data = f.read()
    except Exception as e:
        data = 'omg?'

    return data


@hook('before_request')
def start_session():
    src = request.environ.get('REMOTE_ADDR')
    if not src in ('127.0.0.1', '10.255.0.2', '10.255.0.67', '10.255.0.69', '10.255.0.70'):
        print('omgwtfno? {} no go here'.format(src))
        abort(403, "getthouhence!")

@route('/lsofdatthang')
def lsofdatthang():
    # run the "ps aux" command to get all processes
    data = subprocess.check_output(['ps','aux'])

    # change the byte encoded data to a string; b'asdf' => 'asdf'
    data = data.decode()

    # split that one long string into one string per line we got from ps aux
    data = data.split('\n')

    # now use enumerate() around the list of data[] to give us a line number+line...
    # new variable called ws

    # prepare our data for the HTML template
    webfoo = []
    for line in data:
        # skip blank lines
        if not line:
            continue

        # split each word out, skip multiple blank spaces
        line = [x for x in line.split(' ') if x]

        # create list to append our generated TDs
        tds = []

        # go thru each word, if the word is in index 1,
        # then make an ahref around it. otherwise, just
        # a simple TD "TABLE DATA"
        for i,e in enumerate(line):
            if i==1 and not e=='PID':
                tds.append('<td><a href="/lsof/{pid}">{pid}</a></td>'.format(**{"pid":e}))
            else:
                tds.append('<td>{}</td>'.format(e))
        line = ''.join(tds)
        #tr "Table Row"
        webfoo.append('<tr>')
        webfoo.append(line)
        webfoo.append('</tr>')

    # concatenate this into one string
    pgdata = '\n'.join(webfoo)

    # build a web page of this data

    html = '''\
<!DOCTYPE html>
<html lang='en-US'>
    <head>
     <title>lsof dat thang!</title>
   </head>

   <body>
     <p>lsof output:</p>
     <table>
       <tbody>
         ${pgdata}
       </tbody>
     </table>
   </body>
   </html>
    '''

   # create the template using our initial html string
    T = string.Template(html)

    # fill it in
    html = T.safe_substitute({'pgdata':pgdata})

    # finally, send it back to the browser
    return html

#when traveling to 10.255.0.67 /lsof/ any pid number get data from pid id
@route("/lsof/<pid:int>", method= 'GET')
def lsof(pid):
    #define function lsof passing one parameter int pid
    #assigned data to the subporcess modle with checkoutput method
    #output is generated by running command lsof -PRwnlp
    data = subprocess.check_output(["lsof",'-PRwnlp', str(pid)])
        ##use str(pid) to convert pid intiger into a string to complete method check_output in module subprocess


    html ='''
<!DOCTYPE html>
<html lang='en-US'>
    <head>
     <title>lsof dat thang!</title>
   </head>

   <body>
     <p>lsof output:</p>
         ${pgmdata}
   </body>
   </html>
    '''
    pgmdata = '<xmp>'+data.decode()+'</xmp>'
    pgmdata += '<a href="/downloads">downloads</a>'
    T = string.Template(html)
    html = T.safe_substitute({'pgmdata':pgmdata})
    return html


@route('/images/<path:re:.*>', method='GET')
def images(path):
    return static_file('/images/'+path, root=document_root)

@route('/css/<path:re:.*>', method='GET')
def images(path):
    return static_file('/css/'+path, root=document_root)


@route("/<path:re:.*>", method = "ANY")
def future(path):
    ##allow only certain addresses accsess

    if path == '':
        path = 'index.html'

    if not path in ("page2.html", "index.html", "nickspage.html", "commonsites.html","dolphin.html","divpractice.html", "html.html", ):
        abort(404, "filenotfound")

    if path == "":
        path = "index.html"


    print(document_root,path)
    return static_file (path, root=document_root)

run(host=server_ip, port=1069, debug=True)
